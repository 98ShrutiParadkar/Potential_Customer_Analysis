# -*- coding: utf-8 -*-
"""Potential_Customer_Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-8HTLM3N1BpNBPo1fZn2MWh-ypatbXOY

# Customer Analysis and Best-Selling Product Identification

This script is designed to analyze customer characteristics and identify the best-selling products, enabling businesses to focus on the most profitable market segments. Instead of employing a broad marketing strategy, this approach helps in pinpointing the key customers who contribute the most to revenue generation.

Key Features:
- Determines the best-selling products to optimize marketing strategies.
- Identifies loyal customer characteristics based on historical data.
- Provides insights on  potential customer for targeted marketing and improved business decision-making.

By leveraging this analysis, businesses can refine their market research efforts, ensuring resources are directed toward the most valuable customer segments and products.

### Step 1 : Importing Libraries
"""

import pandas as pd
import numpy as np

"""### Step 2 : Load Datasets"""

# Load Data
transactions = pd.read_csv("/content/transaction_data.csv")
purchase_behaviour = pd.read_csv("/content/purchase_behaviour.csv")

"""### Step 3 : Previewing the Transactions Dataset and Purchase Behaviour dataset"""

transactions.head()

transactions.shape

purchase_behaviour.head( )

purchase_behaviour.shape

"""### Step 4 : Checking Duplicates values"""

# Check for duplicates in LYLTY_CARD_NBR
duplicates_1 = transactions['LYLTY_CARD_NBR'].duplicated().sum()
duplicates_2 = purchase_behaviour['LYLTY_CARD_NBR'].duplicated().sum()

print(f"Duplicates in dataset 1: {duplicates_1}")
print(f"Duplicates in dataset 2: {duplicates_2}")

"""### Step 5 : Merging Datasets"""

# Merge datasets on LYLTY_CARD_NBR
data = pd.merge(transactions, purchase_behaviour, on="LYLTY_CARD_NBR")

data.head()

data.shape

"""### Step 6 : Check Null values"""

# 3. Handle missing values in merged data
print("\nChecking for missing values in merged dataset:")
print(data.isna().sum())

"""### Step 7 : Find Most Profitable Products"""

# Aggregate sales per product
product_sales = data.groupby("PROD_NAME")["TOT_SALES"].sum().reset_index()
top_3_products = product_sales.sort_values(by="TOT_SALES", ascending=False).head(3)

# Print Results
print("Top 3 Most Profitable Products:")
print(top_3_products)

# Visualize the top 3 products
import matplotlib.pyplot as plt
plt.figure(figsize=(6,3))
plt.barh(top_3_products['PROD_NAME'], top_3_products['TOT_SALES'], color='skyblue')
plt.xlabel('Total Sales')
plt.title('Top 3 Most Profitable Products')
plt.gca().invert_yaxis()  # Invert y-axis to show the highest at the top
plt.show()

"""### Step 8 : Check for unique combinations of customer behavior"""

# 1. Get all unique combinations of LIFESTAGE, PREMIUM_CUSTOMER, and any other relevant columns
unique_combinations = data[['LIFESTAGE', 'PREMIUM_CUSTOMER']].drop_duplicates()

# 2. Count the number of unique combinations
num_combinations = unique_combinations.shape[0]

# 3. Print the result
print(f"There are {num_combinations} unique customer behavior combinations.")
unique_combinations

"""### Step 9 : Find total sales and customer count for each combination"""

# Group by LIFESTAGE and PREMIUM_CUSTOMER and aggregate the total sales and count
customer_behavior_sales = data.groupby(['LIFESTAGE', 'PREMIUM_CUSTOMER']).agg(
    total_sales=('TOT_SALES', 'sum'),
    customer_count=('LYLTY_CARD_NBR', 'count')
).reset_index()

# Display the result
print(customer_behavior_sales)
customer_behavior_sales.to_csv("customer_behavior_sales.csv", index=False)

"""### Step : Find loyal and potential customers"""

import pandas as pd
import numpy as np
import warnings
warnings.filterwarnings("ignore")

from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import seaborn as sns

# Calculate the average sales per customer
customer_behavior_sales['avg_sales_per_customer'] = customer_behavior_sales['total_sales'] / customer_behavior_sales['customer_count']

# Select features for clustering
X = customer_behavior_sales[['total_sales', 'customer_count', 'avg_sales_per_customer']]

# Normalize the data for better clustering performance
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Apply KMeans Clustering
kmeans = KMeans(n_clusters=3, random_state=42)
customer_behavior_sales['Cluster'] = kmeans.fit_predict(X_scaled)

# Add the cluster information to the original dataset
customer_behavior_sales['Cluster'] = customer_behavior_sales['Cluster'].astype(str)

# 1. Find Loyal Customers: We can assume loyal customers are in the cluster with the highest total sales and/or average sales per customer
loyal_cluster = customer_behavior_sales.groupby('Cluster').agg({'total_sales': 'sum', 'avg_sales_per_customer': 'mean'}).idxmax()

# 2. Find Potential Customers: Potential customers can be identified as those in clusters with a high number of customers but low sales
# This depends on your business logic, for now we assume clusters with high customer counts and low total sales are potential customers
potential_cluster = customer_behavior_sales.groupby('Cluster').agg({'customer_count': 'sum', 'total_sales': 'sum'}).idxmin()

# Find top 3 loyal and potential customers based on the cluster
loyal_customers = customer_behavior_sales[customer_behavior_sales['Cluster'] == loyal_cluster[0]].nlargest(21,'total_sales')
potential_customers = customer_behavior_sales[customer_behavior_sales['Cluster'] == potential_cluster[0]].nlargest(21,'customer_count')

# Print the results
print("\nTop Loyal Customer characteristics :")
print(loyal_customers[['LIFESTAGE', 'PREMIUM_CUSTOMER', 'total_sales', 'customer_count']])

print("\nTop Potential Customer characteristics :")
print(potential_customers[['LIFESTAGE', 'PREMIUM_CUSTOMER', 'total_sales', 'customer_count']])

# 3. Visualize the Clusters
plt.figure(figsize=(8, 6))
sns.scatterplot(x='total_sales', y='customer_count', hue='Cluster', data=customer_behavior_sales, palette='Set1')
plt.title('Customer Segments Based on Sales and Customer Count')
plt.show()

"""# Conclusion

This analysis successfully identifies high-value customers based on their spending behavior and categorizes them for targeted marketing efforts.The data visualization highlights spending patterns, while segmentation helps in understanding the distribution of customers.<br>

The processed dataset can be further used for predictive modeling and strategic decision-making to enhance customer engagement and retention.
"""